titre: darktable 2.6
auteur: Matthieu Moy (mmoy)- traduction française par Nicolas Auffray (Nilvus)
date: 2018-12-24
lede: butterfly.jpg
lede_author: 
tags: annonce, darktable-release

Comme le veut la tradition, une nouvelle version de darktable est sortie pour Noël : la 2.6.0. 2018 a été une année de renouveau pour darktable, avec de nombreuses fonctionnalités majeures réalisées par de récents contributeurs.

Parmi les principales nouveautés :

* Un nouveau module _retouche_, similaire au module de _correction de taches_, avec copie intelligente (_outil de correction_) et la possibilité d'agir sur chaque niveau de détails individuellement.

* Un nouveau module _filmique_, capable de gérer la plupart des aspects de tonalité d'une image en un seul module, tout en préservant la couleur.

* Une refonte complète du module de _balance des couleurs_, qui peut être vu comme une variante plus orientée couleurs que le module _niveaux_. Grâce à de nouvelles options de sélection de couleurs, ce module permet d'effectuer la plupart des ajustements automatiquement.

* La possibilité de guider le floutage d'un masque de fusion, afin de sélectionner précisément un objet avec le minimum d'effort.

Tout ceci vous est ici dévoilé, et bien d'autres nouveautés, dans la suite de cette dépêche.

# Fonctionnalités principales

## Un nouveau module : _retouche_

Alors que darktable se focalise principalement sur le développement RAW, les dernières versions ont introduit des fonctionnalités habituellement réservées aux éditeurs orientés pixels tel que GIMP, comme le module _liquéfier_. 
Une étape importante de plus dans cette direction est faite avec ce nouveau module _retouche_, qui remplace essentiellement le module _correction des taches_, avec séparation des fréquences pour une retouche fine.

### Améliorations comparées au module _correction des taches_

Le module a bien plus d'options que le module _correction des taches_, mais tout ce que vous pouviez faire avec le précédent reste disponible dans le module _retouche_.

  <div style="text-align: center">
![Aperçu du module retouche](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-overview-fr.png)
  </div>

Comme avec _correction des taches_, vous sélectionnez une forme (cercle, ellipse, chemin, ou brosse ; cette dernière n'existait pas dans _correction des taches_) et vous cliquez simplement sur la partie de l'image que vous souhaitez effacer. Le module va copier une autre partie de l'image pour la masquer. Glissez au lieu de cliquer pour choisir la source à cloner, ou ajustez les contrôles ensuite.

De nombreux détails vont vous faciliter la vie :

#### Outil de correction, de meilleurs résultats en moins d'efforts

Par défaut, la copie utilise un algorithme de correction (*heal* en anglais) emprunté de l'outil correcteur de GIMP, qui adapte la source au contexte de l'emplacement copié. Vous n'avez pas besoin de copier exactement la bonne partie de l'image. Prenons un exemple classique, un petit défaut dans un ciel pas complètement uniforme :

  <div style="text-align: center">
![Exemple de retouche](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-original.png)
  </div>

Une mauvaise tentative pour corriger cela avec l'outil de copie donnerait :

  <div style="text-align: center">
![Retouche par copie (avec contrôles)](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-clone.png)
  </div>

Le morceau de ciel copié pour masquer le défaut est un peu plus sombre que l'endroit où il a été copié. Ce n'est pas évident tant que les outils de contrôle sont affichés sur l'image, mais l'image finale est vraiment mauvaise :

  <div style="text-align: center">
![Retouche par copie (sans contrôles)](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-clone-nocontrol.png)
  </div>

La même retouche  avec le nouvel `outil de correction` (![outil de correction](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-heal-icon.png)) donne ceci :

  <div style="text-align: center">
![Retouche de correction (avec contrôles)](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-heal.png)
  </div>

Cette fois, l'image finale est indistinguable d'un ciel sans défaut :

  <div style="text-align: center">
![Retouche de correction (sans contrôles)](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-heal-nocontrol.png)
  </div>

Même en clonant des parties de l'image de couleurs complètement différentes, l'`outil de correction` réagit étonnamment bien. Poussons le module un peu :

  <div style="text-align: center">
![Retouche de correction sur des couleurs différentes](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-heal-red-white-blue.png)
  </div>

Le morceau blanc est copié vers le t-shirt bleu, le t-shirt bleu vers le rouge, et le rouge vers le blanc. Chaque fois, le contraste local est conservé, mais la couleur générale et la luminance du morceau sont adaptés pour s'ajuster à la destination.

L'`outil de copie` basique (![outil de copie](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-clone-icon.png)) est toujours disponible pour les rares situations où vous en auriez besoin.

#### Remplir et flouter, quand vous n'avez rien à copier

En plus des outils de copie et de correction (qui fonctionnent seulement quand vous avez une partie de l'image à dupliquer sur celle à effacer), le module _retouche_ fournit un `outil de remplissage` (![outil de remplissage](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-fill-icon.png)) (remplir une forme avec une couleur) et un `outil de flou` (![outil de flou](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-blur-icon.png)) (appliquer un flou pour adoucir une partie de l'image). Ces outils sont particulièrement utiles pour l'édition par séparation de fréquence (voir plus bas).

#### Une activation, plusieurs corrections : ajout continu

Les outils peuvent être activés en une fois pour plusieurs corrections. Utilisez simplement la combinaison `Ctrl`-`clic` sur l'un des outils cercle, ligne, ellipse ou chemin (au lieu d'un simple clic), et l'outil restera actif jusqu'à ce que vous le désactiviez explicitement.
Ceci est très pratique lorsque vous avez à corriger plusieurs endroits de la même image, comparé au précédent flux de travail qui vous obligeait à cliquer sur le bouton de l'outil pour chaque correction.

#### Visualisation de la source de correction

Pour les outils de copie et de correction, chaque correction consiste à sélectionner une source et une destination. Un simple clic permet de définir la destination et, par défaut, darktable sélectionne une zone arbitraire pour la source. Une autre option est de définir la source et la destination par un glisser-déposer avec le curseur de la destination vers la source.

Le module _retouche_ introduit un mécanisme plus avancé :

* En déplaçant le curseur sur l'image, la destination à corriger est marquée par une forme, alors que la source est marquée par une petite croix :

  <div style="text-align: center">
![Source & destination de retouche](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-source-cross.png)
  </div>

* Pour sélectionner une source, utiliser `Maj`-`clic` sur l'image. La croix est alors placée sur l'emplacement du curseur et ne bougera plus jusqu'à ce que vous sélectionnez la destination, via un simple clic. Ceci est particulièrement intéressant combiné à une activation permanente de l'outil mentionné ci-dessus : plusieurs corrections sont ainsi possibles sur l'image, la source restant à des coordonnées relatives à la destination.

* Une variante : utiliser `Ctrl`-`Maj`-`Clic` au-lieu de `Maj`-`Clic`. Ceci définira également l'emplacement de la source, mais cette fois, celle-ci restera fixe, selon des coordonnées absolues et non plus relatives à la destination à corriger.

### Édition par séparation de fréquence

Une difficulté classique de la retouche photo, typiquement pour le portrait, est de souhaiter masquer certaines taches, et parfois réduire le contraste local afin de rendre la peau plus lisse, tout en conservant sa texture. Un effacement brutal rendrait la peau trop lisse et donnera à la photo, au mieux, un aspect « excessivement post-traité ».

Prenons une image comme exemple (reprise du [défi pixls.us PlayRaw "Hillbilly portrait"](https://discuss.pixls.us/t/playraw-hillbilly-portrait/5518)) :

  <div style="text-align: center">
![Exemple de portrait](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-overall-portrait.jpg)
  </div>

Une technique commune pour ce type de retouche est de séparer l'image en plusieurs images correspondant à plusieurs niveaux de détails, et de les combiner ensemble. C'est ce que permet le [greffon _Décomposer en ondelettes_ de GIMP (article en anglais)](https://pixls.us/articles/skin-retouching-with-wavelet-decompose/) par exemple.

Après séparation, cela produit une première image trouble aux détails grossiers, et une ou plusieurs images contenant seulement les détails.

Dans notre exemple, nous obtenons :

  <div style="text-align: center">
![Exemple de portrait](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-portrait-scale4.jpg)
  </div>

  <div style="text-align: center">
![Exemple de portrait, échelle 5](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-portrait-scale5.jpg)
  </div>

  <div style="text-align: center">
![Exemple de portrait, échelle 6](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-portrait-scale6.jpg)
  </div>
 
  <div style="text-align: center">
![Exemple de portrait, échelle 7](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-portrait-scale7.jpg)
  </div>

Ce type de transformation est utilisé en interne par le module _égaliseur_, qui permet d'augmenter ou diminuer l'importance de chaque niveau de détails de l'image. Alors que _égaliseur_ travaille globalement sur l'image, _retouche_ permet de sélectionner le niveau de détails et la partie de l'image sur laquelle vous souhaitez travailler.

Dans le module _retouche_, cela correspond à la partie _décomposition en ondelettes_ de l'interface :

  <div style="text-align: center">
![Échelles de décomposition en ondelettes](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-scales-fr.png)
  </div>

Cette partie montre un rectangle par échelle de décomposition (du grain le plus fin à gauche au grain le plus grossier à droite). Le rectangle noir à gauche correspond à l'image entière, et le blanc à droite à l'image résiduelle, c'est-à-dire l'image où tous les autres niveaux de détails ont été enlevés. Par défaut, darktable montre toujours l'image finale, mais vous pouvez visualiser une échelle de détails et l'image résiduelle en cliquant sur le bouton `affiche une seule échelle de décomposition` (![affiche une seule échelle de décomposition](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-display-wavelet-scales.png)).

L'image actuellement sélectionnée apparaît avec un rectangle rouge. Déplacez le curseur du bas pour modifier le nombre d'échelles de détails à utiliser. Selon le niveau de zoom, certains détails d'échelle peuvent être plus fins que le permet la résolution de l'écran, donc inutilisables. La ligne grise sur le dessus des échelles montre lesquelles sont visibles au niveau de zoom actuel.

En visualisant l'échelle de détails, le contraste peut être trop faible ou trop fort,  le module propose donc un ajustement de niveaux (qui s'applique seulement sur la prévisualisation à l'écran, et non sur l'image finale) :

  <div style="text-align: center">
![Niveaux d'ajustement](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-levels-fr.png)
  </div>

Chaque type d'outil présenté ci-dessus (`outil de correction`, `outil de copie`, `outil de remplissage` ou `outil de flou`) est utilisable sur chacune de ces échelles. Pensez-y comme à des calques obtenus d'une image source, et recomposés ensemble, après retouche, afin d'obtenir l'image finale. C'est là où les outils de `remplissage` et de `flou` prennent le plus de sens : `outil de remplissage` est par défaut un mode d'effacement lorsque la couleur choisie est le noir, ce qui correspond à supprimer les détails lorsqu'il est utilisé sur les échelles de détails. Il est aussi possible de sélectionner une couleur et de remplir avec celle-ci (particulièrement utile sur l'échelle de l'image résiduelle). Utiliser l'`outil de flou` directement sur l'image, aboutit à des résultats de post-traitement clairement visibles, mais l'utiliser de manière sélective sur les échelles permet d'aboutir à des effets plus subtils.

#### Exemple 1: réduction de tâche au lieu de suppression

Concentrons-nous sur le bouton situé sous la branche des lunettes. Si nous souhaitons le supprimer complètement, il est facile de le faire avec l'`outil de correction`. Maintenant, que se passe-t-il si nous souhaitons le conserver, et seulement le réduire, pour qu'il n'attire plus l'attention ? Nous pouvons simplement le supprimer depuis l'échelle de détails grossiers (échelle 6 dans notre exemple).
Le bouton n'est alors plus visible sur l'image résiduelle, le supprimer depuis l'échelle de détails est donc suffisant. L'`outil de correction` permet de le faire proprement. Mais en agissant avec l'échelle de détails, l'`outil de remplissage` et l'`outil de flou` peuvent aussi donner de bons résultats. Voici ci-dessous le résultat sur l'échelle 6 (avant à gauche, après à droite).

  <div style="text-align: center">
![Avant/après à l'échelle 6](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-before-after-scale6.jpg)
  </div>

L'image finale sera transformée comme suit :

  <div style="text-align: center">
![Avant/après à l'échelle  6 (image finale)](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-before-after-final.jpg)
  </div>

Désormais, nous pouvons décider que la correction faite sur l'échelle 6 peut aussi s'appliquer à l'échelle 5. Nous pouvons faire la même chose manuellement, mais nous pouvons également utiliser le curseur du haut, intitulé `début de fusion`, afin de reproduire automatiquement les formes corrigées sur plusieurs échelles. Toute forme créée à droite de ce curseur sera reproduite sur toutes les échelles au delà de ce curseur de fusion (excepté si le curseur est positionné complètement à gauche (à 0), ce qui signifie que la fusion est désactivée).

Par exemple, en positionnant le curseur à 5, nous appliquons la correction sur les échelles 5 et 6, et obtenons ceci :

  <div style="text-align: center">
![Après à l'échelle 5](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-merge-5-6.jpg)
  </div>

Si nous déplaçons le curseur plus à gauche, le bouton disparaît progressivement. Selon ce même principe, nous pouvons effacer les marques sur la peau tout en préservant les poils de la barbe :

  <div style="text-align: center">
![Avant/après, en préservant la barbe](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-beard-preserve.jpg)
  </div>

(Juste une correction sur l'échelle 7, propagée ensuite jusqu'à l'échelle 5 en utilisant le curseur de fusion)

#### Exemple 2 : jouer avec la texture de peau

Si vous voulez changer la texture de peau sur la joue, vous pouvez appliquer un flou sur une forme de ce type :

  <div style="text-align: center">
![Flou sur une échelle de détail](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-blur-detail.jpg)
  </div>

et obtenez le résultat avant/après suivant :

  <div style="text-align: center">
![En changeant la texture de peau](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-skin-texture.jpg)
  </div>

De toute évidence, ce type de retouche doit être pratiqué avec une grande prudence : si la correction est poussée trop loin, cela produira un rendu trop artificiel.

En cas de doute, vous pouvez toujours revenir en arrière sur votre retouche et utiliser un mode de fusion avec une opacité inférieure à 100%, ou modifier l'opacité ou le rayon de flou de chaque forme individuellement.

#### Exemple 3 : s'amuser avec l'image résiduelle

Juste pour le plaisir (ne reproduisez pas ça chez vous, ou attendez-vous à des images horribles !), nous pouvons obtenir un effet « tatouage » en utilisant l'`outil de copie` sur l'image résiduelle :

  <div style="text-align: center">
![Copie sur l'image résiduelle](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-clone-residual-image.jpg)
  </div>

Bien que peu élégant, cet exemple illustre le principe de « séparation de fréquences » : nous avons conservé les détails fins de la joue, et copié des détails grossiers de l'image résiduelle.

## Nouveau module : _filmique_

Le module _filmique_ a été conçu pour reproduire les meilleurs aspects d'un film analogique associés aux contrôles plus aisés de la photographie numérique. Il peut être utilisé sur toute image en remplacement du module _courbe de base_, et est particulièrement adapté pour les images à grande plage dynamique (high dynamic range - HDR), c'est-à-dire avec une différence importante entre les zones les plus claires et les plus sombres de l'image.

Prenons un exemple d'une telle image (extrait du [défi pixls.us PlayRaw "Backlit"](https://discuss.pixls.us/t/playraw-raw-challenge-backlit/1676)) :

  <div style="text-align: center">
![Exemple d'image HDR](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/filmic-example-image.jpg)
  </div>

Une approche commune pour agir avec des images à plage dynamique étendue (HDR) est de comprimer le contraste global tout en conservant le contraste local. darktable a plusieurs modules capables de faire cela : _mappage tonalités_, _mappage global tonalités_, _ombres et hautes lumières_, et depuis darktable 2.2, le mode `fusion d'exposition` dans le module _courbe de base_. Cette compression de contraste fonctionne jusqu'à un certain point, les résultats pouvant donner un aspect artificiel si poussée trop loin. Ce que vous souhaitez typiquement éviter est ceci (le module _mappage de tonalités_ a été utilisé, le curseur de contraste à son maximum) :

  <div style="text-align: center">
![Exemple d'image HDR](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/filmic-hdr-too-much.jpg)
  </div>

Le module _filmique_ montre qu'une autre approche est possible et, généralement, donne des résultats plus naturels. Il considère chaque pixel individuellement, sans faire de distinction entre le contraste global et local. Si _filmique_ comprime trop le contraste, il est toujours possible de récupérer le contraste local avec l'excellent module _contraste local_ par exemple.

Le module _filmique_ est fait pour être utilisé sans le module _courbe de base_ (activé par défaut dans darktable). La _courbe de base_ vient très tôt dans le pipeline graphique et donne une image contrastée, dans laquelle les hautes lumières sont souvent atténuées. Récupérer les détails perdus via _courbe de base_ est difficile. D'autre part, simplement désactiver _courbe de base_ entraîne généralement des images pâles, manquant de contraste et de saturation. D'autres techniques d'amélioration du contraste doivent être utilisées pour compenser cela. Le module _filmique_ vient plus tard que _courbe de base_ dans le pipeline graphique, et donne plus de contrôle pour exploiter correctement la plage dynamique de l'image de sortie.

La première chose que fait _filmique_ est d'appliquer une courbe logarithmique sur l'image, de sorte que les « stops » (puissance de deux de luminance d'un espace linéaire) soient répartis uniformément sur l'histogramme.

La source d'inspiration derrière _filmique_ est le film analogique. Une différence entre le film analogique et les capteurs numériques est la manière dont ils réagissent à la surexposition. Les capteurs numériques ont un seuil d'écrêtage au-dessus duquel tout est considéré blanc : ils ne peuvent pas faire la distinction entre les pixels légèrement supérieurs au seuil et les pixels surexposés. Le film analogique réagit différemment : le contraste est réduit progressivement à mesure que l’image est surexposée, sans cet effet de seuil. Cela permet aux films analogiques de restituer une scène avec une plage dynamique élevée sur un support avec une plage dynamique inférieure, tout en maintenant le contraste et la saturation dans les tons moyens.

Un effet similaire peut être obtenu dans le monde numérique en appliquant une courbe  en S à l'image, tant que les hautes lumières ne sont pas écrêtées. Avec le module _courbe de tonalités_, on peut dessiner une courbe telle que celle-ci :

  <div style="text-align: center">
![Ajustement d'exposition](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/filmic-S-shaped.png)
  </div>

La seconde chose que fait _filmique_ est d'appliquer une telle courbe, mais au lieu de fournir cette courbe manuellement, la courbe est automatiquement calculée depuis un ensemble de paramètres. Cela facilite l'équilibrage des ombres, hautes lumières et tons moyens.

### Exemple d'image

Traitons notre image avec ce module. Avant d'appliquer _filmique_, nous devons d'abord désactiver le module _courbe de base_, et ensuite ajuster l'_exposition_. Aucun pixel ne doit être surexposé ou sous-exposé. Dans notre situation, nous devons réduire l'exposition afin d'éviter de surexposer le ciel :

  <div style="text-align: center">
![Ajustement d'exposition](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/filmic-exposure-fr.png)
  </div>

Afin que les paramètres automatiques fonctionnent de leur mieux, il est recommandé d'utiliser le mode `AMaZe` du module _dématriçage_. Activer un module de _réduction de bruit_ avant _filmique_, dans le pipeline graphique (ex. : _réduction de bruit (profil)_), peut également aider.

### Transformation logarithmique

La première chose affichée dans le module _filmique_ est un aperçu de la courbe appliquée à l'image. La courbe n'est pas directement éditable, l'objectif du module étant d'ajuster la courbe via les curseurs situés en dessous.

Afin d'avoir un bon point de départ de travail, _filmique_ fournit une pipette de réglage de `niveaux automatiques `. Par défaut, ce module considère l’ensemble de l’image et définit les trois curseurs ci-dessus en fonction de la luminance moyenne, de la zone la plus lumineuse et de la zone la plus sombre :

  <div style="text-align: center">
![En un clic sur niveaux automatiques](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/filmic-autotune-levels-fr.png)
  </div>

À ce stade, l'histogramme doit remplir toute la plage, mais aucun pixel ne doit être sous ou surexposé. Si ce n’est pas le cas, vous pouvez corriger le problème avec le curseur `facteur de sécurité` : le glisser vers la droite comprime la plage dynamique (l’histogramme doit donc apparaître centré, avec des parties vides à gauche et à droite), et inversement, le glisser vers la gauche l'étends de sorte que les ombres et hautes lumières commencent à s'écrêter. Le curseur noir peut être défini en précisant la plage dynamique de l’image (sur une image suffisamment contrastée, c’est la plage dynamique de la caméra, c’est-à-dire environ 14 EV sur un appareil haut de gamme ou environ 10 EV pour un appareil compact moyen). Le curseur noir peut être défini par la valeur du blanc moins la plage dynamique. Alternativement, on peut déplacer le curseur pour laisser l'histogramme s'étendre sur son axe horizontal.

Dans notre cas, l'outil `niveaux automatiques` a fait le travail correctement, nous allons donc conserver les curseurs tels qu'ils sont. L'histogramme est réparti sur la plage dynamique de l'image cible. Aucun pixel n'est surexposé :

  <div style="text-align: center">
![Histogramme après ajustement](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/filmic-adjust-histogram.png)
  </div>

C'est ici que la magie opère : la pipette de _luminance de gris moyen_ permet de choisir quelle partie de l'image sera considérée comme gris moyen (50% de luminance). Par exemple, si nous le définissons sur la joue du chien, nous obtenons ceci :

  <div style="text-align: center">
![Gris moyen via la joue du chien](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/filmic-middle-grey-dog-fr.png)
  </div>

Si nous sélectionnons le nez du chien, qui est plus foncé, nous obtenons une image plus claire :

  <div style="text-align: center">
![Gris moyen via le nez du chien](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/filmic-middle-grey-nose-fr.png)
  </div>

D'autre part, si nous sélectionnons une zone claire du ciel, l'exposition globale est diminuée afin d'obtenir une exposition correcte du ciel :

  <div style="text-align: center">
![Gris moyen via le ciel](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/filmic-middle-grey-sky-fr.png)
  </div>

Sur toutes ces images, les points blancs et noirs sont conservés, et ne sont pas sur ou sous-exposés. Au final, sélectionner l'herbe derrière le chien est probablement la meilleure option ici, mais c'est une question de goût :

  <div style="text-align: center">
![Gris moyen via l'herbe](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/filmic-middle-grey-grass-fr.png)
  </div>

L'utilisation de l'image complète avec le curseur `luminance du gris moyen` est également un choix sûr. C'est ce que fait `niveaux automatiques`.

### _Courbe filmique en S_

Allons maintenant découvrir la seconde partie de ce module : la `courbe filmique en S`. Cette courbe va principalement permettre d'augmenter le contraste dans les tons moyens (le curseur `contraste`) et comprimer les ombres et/ou hautes lumières. Peut-être ne l'avez-vous pas remarqué, mais le module _filmique_ a déjà initié cela à son activation, le curseur de `contraste` étant défini par défaut à 1.5. Si nous désactivons la `courbe filmique en S` (donc définir le `contraste` à 1), nous obtenons une image plus terne :

  <div style="text-align: center">
![Pas de contraste dans la courbe en S](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/filmic-no-contrast-fr.png)
  </div>

D'autre part, nous pouvons définir plus de contraste que l'option par défaut :

  <div style="text-align: center">
![Contraste élevé sur la courbe en S](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/filmic-high-contrast-fr.png)
  </div>

Bien sûr, à un certain niveau, augmenter le contraste entraînera une perte d'informations dans les ombres et/ou hautes lumières,  La courbe en haut du module permet de voir quelle information est perdue : idéalement la courbe ne devrait pas toucher le bas ou le haut du cadre.

Par exemple, si vous obtenez la courbe ci-dessous, la texture est perdue dans les noirs :

  <div style="text-align: center">
![Ombres saturées](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/filmic-curve-clipped-shadows.png)
  </div>

En d'autres termes, ou vous avez détruit vos ombres, ou vous avez volontairement écrêté afin d'obtenir des noirs plus profonds.

Les curseurs sous `contraste` permettent d'affiner précisément la courbe :

* `latitude` définit la gamme de l'image correspondant aux tons moyens sur lesquels le contraste sera augmenté.

* `équilibre ombres-hautes lumières` définit la place à donner aux ombres ou aux hautes lumières.

* Le menu de contrôle `rendu` contrôle l'interpolation entre les points de la courbe. La valeur par défaut donne généralement de bons résultats, mais peut aussi être totalement fausse (par exemple, produire une courbe non monotone) lorsque vous poussez les paramètres à leur extrême. Essayez d'autres modes lorsque cela se produit.

L'augmentation du contraste produit souvent une augmentation de la saturation dans les ombres, et une augmentation dans les hautes lumières, ce qui peut amener à un écrêtage de gamut. Le curseur `saturation` permet de diminuer la saturation dans les extrémités des ombres et hautes lumières afin d'éviter cela. D'autre part, dans les hautes lumières, darktable doit habituellement choisir entre la préservation de la luminance et de la chrominance. Par défaut, il préserve la luminance mais il est possible de privilégier la chrominance par le biais de la case à cocher correspondante. En préservant la chrominance, les images résultantes sont souvent perçues comme étant sur-saturées, et nécessitera plus d'attention ultérieurement dans le pipeline (c'est-à-dire définir la saturation de sortie du module _balance couleur_ à 75%).

Il existe une section masquée `destination/affichage`, peu utile pour la plupart des utilisateurs. Attendez-vous à des images horribles si vous l'utilisez sans lire le manuel et savoir ce que vous faites !

### Touche finale et contraste local

Le contraste a été comprimé dans le ciel, mais nous voyons toujours un peu de texture. Si nous voulons augmenter le contraste local du ciel, le module _contraste local_ avec un masque paramétrique sur la partie la plus claire de l'image produit ce résultat :

  <div style="text-align: center">
![Gris moyen via l'herbe](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/filmic-and-local-contrast.jpg)
  </div>

Il est aussi possible de désactiver l'effet de _filmique_ en utilisant les masques, par exemple en excluant les hautes lumières pour éviter ici la compression de contraste. 
Un adoucissement du masque sera en général nécessaire pour éviter les bords abrupts ou halos.

### Documentation complémentaire

Cette partie vous donne un aperçu de ce qui est possible avec le module _filmique_. Bien entendu, il est recommandé de lire le manuel de darktable pour plus de précisions.

Pour de plus amples informations (plus de détails techniques, comparaison avec d'autres techniques, exemples d'images réelles...), vous pouvez également lire l'article suivant (en anglais) : « [Filmic, darktable and the quest of the HDR tone mapping](https://eng.aurelienpierre.com/2018/11/30/filmic-darktable-and-the-quest-of-the-hdr-tone-mapping/) », par Aurélien Pierre, le créateur du module.

## Gestionnaire de clones dans la chambre noire

Avec darktable, vous pouvez conserver plusieurs historiques différents de la même image. En cliquant sur le bouton `cloner` dans le module _images sélectionnées_ de la table lumineuse, cela donne un clone de l'image : le fichier RAW n'est pas copié, mais darktable conserve ainsi deux piles d'historique distinctes pour cette image.

De plus, darktable 2.6 facilite le travail avec les clones, grâce au nouveau module apparaissant dans le panneau gauche de la chambre noire :

  <div style="text-align: center">
![Gestionnaire de clones](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/dm-initial-fr.png)
  </div>

Première amélioration : de fait, le module étant dans la chambre noire, il est désormais possible de travailler avec les différents clones, sans quitter cette dernière.

Deuxième amélioration : un bref commentaire peut désormais être associé à chaque clone de l'image. Supposons que nous souhaitions comparer notre image développée via le module _filmique_ avec un développement fait via la fonction de `fusion d'exposition` du module _courbe de base_. Nous pouvons démarrer avec un ajustement d'exposition basique et conserver cette version pour des développements futurs :

  <div style="text-align: center">
![Gestionnaire de clones](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/dm-basic-fr.png)
  </div>

Ensuite, un clic sur le bouton `créer un clone avec le même historique` (![créer un clone](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/dm-create-duplicate.png)) donne un clone sur lequel nous pouvons appliquer notre traitement basé sur le module _filmique_ :

  <div style="text-align: center">
![Gestionnaire de clones](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/dm-filmic-fr.png)
  </div>

Afin d'obtenir une nouvelle version, nous sélectionnons d'abord le premier par un `double-clic` avant de créer un clone :

  <div style="text-align: center">
![Gestionnaire de clones](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/dm-fusion-fr.png)
  </div>

Pour comparer les clones, un simple `clic prolongé` sur un autre montre cette version de l'image à un niveau de zoom ajusté à l'écran. Il vous faudra maintenir le clic jusqu'à ce que l'image soit affichée complètement la première fois. L'opération sera immédiate par la suite, vous permettant de cliquer et relâcher plusieurs fois afin d'obtenir une comparaison avant/après instantanée.

Notez bien que les miniatures de l'image sont seulement mises à jour lorsque vous quittez l'image. La miniature de l'image tout juste éditée n'est donc, en général, pas à jour.

## Refonte du module _balance couleur_

Le module _balance couleur_ a été considérablement amélioré. Bien que son nom contient le mot « couleur », c'est un module plus général que cela. Il peut ajuster les niveaux à peu près comme le module _niveaux_ et peut également ajuster le contraste avec une courbe proche de la courbe en S du module _filmique_. Bien entendu, vous pouvez également toujours ajuster les couleurs pour ajouter ou supprimer une dominante de couleur dans les ombres, les hautes lumières et les tons moyens séparément.

Le module gagne deux modes de fonctionnement en mode ProPhotoRGB. De plus, vous avez maintenant le choix entre les anciens `contrôles des couleurs` `RGBL` (rouge, vert, bleu, luminance) et `TSL` (teinte, saturation, luminance).

Jouons avec le module sur une image avec plusieurs balances de blancs. Il s'agit de l'image d'origine, avec uniquement les modules de base activés et la courbe de base désactivée :

  <div style="text-align: center">
![Liste des modules actifs](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/cb-active-modules-fr.png)
  </div>

La neige est évidemment blanche dans la scène réelle, mais la neige exposée au soleil reflète la lumière de ce dernier, tandis que celle dans l'ombre reflète la lumière du ciel, beaucoup plus bleue. Le module _pipette_ dans la barre latérale gauche de la chambre noire permet de visualiser et de quantifier ces dominantes de couleurs :

  <div style="text-align: center">
![Échantillons de la pipette couleur](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/cb-patches-original-fr.png)
  </div>

(La valeur négative pour le canal 'b' représente la couleur bleue)

Le module _balance couleur_ dispose maintenant d'une pipette pour neutraliser les couleurs. Sur cette image, l'optimiseur automatique fonctionne plutôt bien. Après un clic sur `neutraliser les couleurs`, la dominante bleue dans les ombres est réduite :

  <div style="text-align: center">
![Optimisation automatique via le module balance couleur](https://raw.githubusercontent.com/Nilvus/dtorg/ed56dde40b561aa851bbe0c568d520377d5489c5/content/blog/2018-12-25-darktable-2.6/cb-picker-neutralize-fr.png)
  </div>

En regardant de plus près les patchs sélectionnés par la pipette, notez que la valeur 'b' est maintenant beaucoup plus proche de 0 :

  <div style="text-align: center">
![Échantillons couleur après normalisation](https://raw.githubusercontent.com/Nilvus/dtorg/593ec883671f7f39454711ceb0a69fad8cac5db7/content/blog/2018-12-25-darktable-2.6/cb-patches-neutralized-fr.png)
  </div>

Si l'optimiseur automatique se trompe, il est possible de spécifier des patchs de couleur pour les hautes lumières, les ombres et les tons moyens (de préférence dans cet ordre) séparément avec les pipettes de couleurs correspondantes. Et, si nécessaire, de relancer la fonction `neutraliser les couleurs` (intitulée `neutraliser les couleurs à partir des patchs` une fois que vous avez sélectionné ces patchs).

De même, les tonalités peuvent être ajustées de la même manière que via le module _niveaux_, soit avec la fonction `optimiser luma`, soit avec des sélecteurs individuels.
La section `maître` en haut permet de régler le contraste et la saturation globale. Les curseurs `contraste pivot` et `contraste` appliquent une courbe, centrée autour du pivot et avec une pente donnée par le contraste. En d’autres termes, avec un contraste positif, les parties de l’image situées en dessous du pivot seront assombries et les parties situées au-dessus auront leur luminance augmentée :

  <div style="text-align: center">
![Gestion de contraste dans le module balance couleur](https://raw.githubusercontent.com/Nilvus/dtorg/ed56dde40b561aa851bbe0c568d520377d5489c5/content/blog/2018-12-25-darktable-2.6/cb-contrast-fr.png)
  </div>

Bien sûr, l'étalonnage des couleurs est toujours la fonction principale du module _balance couleur_. Par exemple, pour obtenir un look ancien, avec des ombres bleues et estompées, nous pouvons utiliser la section `ombres : lift / offset`. Définissez le curseur `facteur` sur une valeur positive (afin que les noirs ne soient pas complètement noirs), la `teinte` sur une couleur bleutée, et utilisez le curseur de `saturation` afin de contrôler l'intensité de la coloration. Cela peut donner lieu à des images comme celle-ci (image prise du défi [RAW de la semaine] (https://froknowsphoto.com/raw-edit-de-le-week-25/)) :

  <div style="text-align: center">
![Virage partiel avec la balance des couleurs](https://raw.githubusercontent.com/darktable-org/dtorg/7b34e51bed7eb4b302b8a83c1a63d20f0495578c/content/blog/2018-12-25-darktable-2.6/cb-split-toning-fr.jpg)
  </div>

Dans cet exemple, les curseurs ont été poussés un peu loin afin d'obtenir un résultat  clair, mais le module peut également obtenir des effets plus subtils, particulièrement lorsqu'il est combiné avec les masques paramétriques. Voyez par exemple le pré-réglage "virage partiel bleu-sarcelle/orange" ajouté au module dans cette version (avant pour la première image, après l'application du pré-réglage pour la seconde) :

  <div style="text-align: center">
![Avant color-grading](https://i.ibb.co/Lk1mW2x/sans.png)
  </div>
  <div style="text-align: center">
![Après color-grading](https://i.ibb.co/xMPF7TM/color-grading.png)
  </div>

## Floutage par détection de bords des masques de fusion

La fonction de fusion de darktable permet de sélectionner une partie de l'image, appelée un masque, afin d'appliquer la transformation apportée par le module sur cette partie. Après création du masque (dessiné ou paramétrique), il est possible d'adoucir les bords du masque avec un effet de floutage.

Grace à darktable 2.6, vous avez plus de contrôle sur la manière dont le floutage du masque est rendu. Afin d'en comprendre le fonctionnement, regardons les deux principales méthodes de floutage. La plus commune est le flou gaussien, qui donne en gros le même effet qu'une photo avec une mise au point incorrecte. En flou gaussien, la valeur (luminance et chrominance) de chaque pixel est diffusée uniformément aux pixels environnants. L'effet de diffusion s'atténue à mesure qu'on s'éloigne du pixel de départ. Dans darktable, le flou gaussien est disponible dans le module _filtre passe-bas_ :

  <div style="text-align: center">
![Copie sur l'image résiduelle](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/gaussian-blur-fr.png)
  </div>

Un autre type de floutage se base sur le [_filtre bilatéral_ (article en anglais)](https://en.wikipedia.org/wiki/Bilateral_filter), parfois appelé flou de surface (en raison du nom de l'outil correspondant dans Photoshop), ou floutage par détection de bord. Dans ce mode, la valeur de chaque pixel est étendue aux pixels environnants, mais l'influence d'un pixel est réduite quand les pixels ont des valeurs différentes. Par exemple :

  <div style="text-align: center">
![Copie sur l'image résiduelle](https://raw.githubusercontent.com/Nilvus/dtorg/b3118285ba128ef422d5b0e6b3f08a589efdf73a/content/blog/2018-12-25-darktable-2.6/edge-aware-blur-fr.png)
  </div>

Un algorithme de floutage similaire peut être appliqué au masque, mais cette fois le masque est flouté et l'image résultante sert de guide pour le floutage. Ceci permet de définir grossièrement le masque et de l'affiner ensuite précisément avec les curseurs.

Supposons que nous souhaitions améliorer la couleur du ciel. Dans le module _zones de couleurs_, nous pouvons sélectionner le ciel avec un masque dessiné :

  <div style="text-align: center">
![Masque dessiné](https://raw.githubusercontent.com/Nilvus/dtorg/b3118285ba128ef422d5b0e6b3f08a589efdf73a/content/blog/2018-12-25-darktable-2.6/gb-mask-fr.png)
  </div>

Évidemment, le résultat est pire avec un flou gaussien sur ce masque (le seul qui était disponible dans darktable 2.4) :

  <div style="text-align: center">
![Masque dessiné](https://raw.githubusercontent.com/Nilvus/dtorg/3654bb506b012e1b738c5b0ff9a553b5fce7cecb/content/blog/2018-12-25-darktable-2.6/gb-mask-gauss-fr.png)
  </div>

Cependant, en poussant le curseur du `rayon adoucissement`, le masque s'ajuste automatiquement au ciel, sans propagation aux montagnes. L'adoucissement réduit un peu l'opacité du masque. Cela peut être compensé avec le curseur d'`opacité du masque`. Et voilà :

  <div style="text-align: center">
![Masque dessiné](https://raw.githubusercontent.com/Nilvus/dtorg/3654bb506b012e1b738c5b0ff9a553b5fce7cecb/content/blog/2018-12-25-darktable-2.6/gb-mask-feather-fr.png)
  </div>

Notez qu'en poussant les curseurs de `rayon adoucissement` et `opacité du masque`, cela vous donne un outil similaire à l'_outil de sélection contiguë_ de GIMP,  souvent demandé par les utilisateurs de darktable : sélectionnez quelques pixels dans une zone et laissez l'outil sélectionner les pixels similaires environnants.

Par exemple, via un coup de pinceau à l'intérieur de la maison :

  <div style="text-align: center">
![Pinceau, sans adoucissement](https://raw.githubusercontent.com/Nilvus/dtorg/3654bb506b012e1b738c5b0ff9a553b5fce7cecb/content/blog/2018-12-25-darktable-2.6/gb-brush-nofeather-fr.png)
  </div>

Et maintenant en augmentant l'adoucissement :

  <div style="text-align: center">
![Pinceau, avec adoucissement](https://raw.githubusercontent.com/Nilvus/dtorg/3654bb506b012e1b738c5b0ff9a553b5fce7cecb/content/blog/2018-12-25-darktable-2.6/gb-brush-feather-fr.png)
  </div>

# Améliorations de la table lumineuse et de la table

* La recherche d'un lieu depuis la vue _carte_ a été corrigée :

  <div style="text-align: center">
![Recherche d'un lieu depuis la vue carte](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/map-search-fr.png)
  </div>

* L'aspect de la table lumineuse a été amélioré. Le texte de fond de l'image était souvent illisible car masqué par l'image. L'état de la copie locale est désormais affiché dans l'angle haut droit.

Dans darktable 2.6 :

  <div style="text-align: center">
![table lumineuse dans darktable 2.6](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/lt-after-fr.png)
  </div>

Précédemment, la même configuration s'affichait ainsi :

  <div style="text-align: center">
![table lumineuse avant la version 2.6](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/lt-before-fr.png)
  </div>

* On peut maintenant afficher les métadonnées des images sur la miniature dans la table lumineuse et dans les bandeaux en bas de la chambre noire :
  <div style="text-align: center">
![Activation des métadonnées sur miniatures](https://raw.githubusercontent.com/moy/dtorg/master/content/blog/2018-12-25-darktable-2.6/thumb-overlay-fr.png)
  </div>
Une fois activé, les informations s'affichent quand on passe la souris sur la miniature :

  <div style="text-align: center">
![Métadonnées sur miniatures](https://raw.githubusercontent.com/moy/dtorg/master/content/blog/2018-12-25-darktable-2.6/thumb-overlay-lighttable-fr.jpg)
  </div>

* On peut maintenant trier les images selon l'`aspect` (éventuellement après un recadrage dans darktable) :

  <div style="text-align: center">
![Trier selon l'aspect](https://raw.githubusercontent.com/Nilvus/dtorg/2f031849b7818b775cee0151502daa2ad16f6195/content/blog/2018-12-25-darktable-2.6/lt-sort-by-fr.png)
  </div>

* Il est aussi possible de spécifier l'ordre manuellement, en sélectionnant _tri personnalisé_ puis par un glisser-déposer des images afin de les réordonner :

  <div style="text-align: center">
![Tri personnalisé](https://raw.githubusercontent.com/Nilvus/dtorg/2f031849b7818b775cee0151502daa2ad16f6195/content/blog/2018-12-25-darktable-2.6/lt-custom-sort-fr.png)
  </div>

* Les collections peuvent maintenant être filtrées par _aspect_, _exposition_ et _copie locale_ :

  <div style="text-align: center">
![Filtres de collection](https://raw.githubusercontent.com/Nilvus/dtorg/2f031849b7818b775cee0151502daa2ad16f6195/content/blog/2018-12-25-darktable-2.6/lt-collection-filters-fr.png)
  </div>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Le filtre `aspect`permet notamment de sélectionner par format : seulement les images au format portrait (ratio d'aspect < 1) ou paysage (ratio > 1) ou format carré (ratio =1).

* En sélectionnant un filtre dans _filtres de collection_, le nombre d'images correspondant à chaque filtre est affiché. Dans l'exemple ci-dessous, 12 images ont été prises à un temps d'exposition d'1/2000" et 6 à 1/1600" :

  <div style="text-align: center">
![Nombre d'images par collection](https://raw.githubusercontent.com/Nilvus/dtorg/2f031849b7818b775cee0151502daa2ad16f6195/content/blog/2018-12-25-darktable-2.6/lt-collection-nb-fr.png)
  </div>

* Il est maintenant possible d'avoir des barres de défilement dans les vues _table lumineuse_ et _chambre noire_. Elles sont désactivées par défaut dans la chambre noire, mais peuvent être activées si nécessaire à partir des `préférences globales` (au bas de l'onglet `options de l'interface`) :

  <div style="text-align: center">
![Configuration des barres de défilement](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/scrollbars-config-fr.png)
  </div>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Les barres de défilement apparaissent autour de la partie centrale de l'interface :

  <div style="text-align: center">
![Barres de défilement dans la chambre noire](http://matthieu-moy.fr/tmp/2018/wip-dt/blog/2018-12-25-darktable-2.6/darkroom-scrollbars.jpg)
  </div>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dans la vue _table lumineuse_, les barres de défilement sont le seul moyen de se déplacer rapidement dans une très grande collection d’images.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dans la vue _chambre noire_, le déplacement peut s'effectuer sans barres de défilement en faisant glisser la souris sur l'image ou en utilisant l'aperçu en haut à gauche de la fenêtre, les barres de défilement étant ainsi beaucoup moins nécessaires.

* La prise en charge des groupes d'images a été améliorée. Des groupes d'images peuvent être créés en sélectionnant des images et en cliquant sur `grouper` dans le module _images sélectionnées_. Une fois cela fait, le bouton `G` en haut de la table lumineuse permet de basculer entre le mode « replié » où seule la tête de groupe est affichée et le mode « étendu ». En mode replié, des actions telles que l'évaluation (étoiles) et les étiquettes de couleur sont appliquées à l'ensemble du groupe.

* De plus, il est désormais possible de trier par groupe afin que ceux-ci restent ensemble. L'image principale du groupe est affichée en premier. Sinon, l'ordre est identique au tri par `numéro`.

* Le module d’_impression_ a été amélioré : il est maintenant possible de choisir le type de papier et, lors de l’utilisation de TurboPrint, la fenêtre d'impression complète de TurboPrint s’affiche avant l’impression.

* Les _filtres de collection_ de la _table lumineuse_ ont désormais 3 modes permettant d'interagir avec les tags hiérarchiques. Lorsque vous sélectionnez un tag qui n'est pas un nœud (c'est-à-dire un tag avec des sous-étiquettes), donc le tag « parent » :
  * Un `double-clic` sélectionne seulement les images marquées uniquement avec ce tag. La recherche est définie sur le « parent ».
  * Un `Contrôle`-`double-clic` sélectionne seulement les enfants, c'est-à-dire les images taguées avec « parent|enfant » et pas seulement « parent ». La recherche est définie sur « parent|% », où « % » signifie « toute chaîne ».
  * Un `Majuscule`+`double-clic` sélectionne les images marquées avec le tag lui-même ou l'un de ses enfants. La chaîne de recherche est définie sur « parent% ».

# Autres fonctionnalités importantes

## Contrôle plus fin sur le bruit pour les modules _réduction du bruit (profil)_ et _réduction du bruit RAW_

De nouvelles courbes ont été introduites afin de permettre un contrôle plus fin du mode `ondelettes` des modules _réduction du bruit (profil)_ et _réduction du bruit RAW_. Ces courbes permettent de contrôler la force du débruitage fréquence par fréquence.
En d'autres termes, vous pouvez adapter la force du débruitage en fonction de l'importance du grain produit par le bruit. La courbe `tout` permet de changer la force de tous les canaux en même temps, tandis que les courbes `R`, `G` et `B` permettent de changer la force séparément pour les canaux rouge, vert et bleu.
Il était déjà possible de débruiter de manière sélective les canaux rouge, vert et bleu en utilisant ensuite les modes de fusion `canal RGB rouge / vert / bleu`, mais le nouveau module peut le faire avec une seule instance et sans fusion.

Tout d'abord, regardons un exemple de ce qui peut être fait avec les courbes `tout`.
Pour commencer, effectuez un zoom à 100% sur l’image. À des niveaux de zoom inférieurs, le résultat est une approximation qui n’est pas toujours précise.
Actionnons ensuite le module de _réduction du bruit (profil)_, en mode `ondelettes`.
Une force comprise entre 0,150 et 0,3 est généralement un bon point de départ.
Ici, pour mieux voir l’influence de la courbe, nous utilisons une force de 0.5.

Voici ici l'image que nous obtenons avec une courbe plate :

  <div style="text-align: center">
![Bateau débruité à l'aide d'une courbe plate](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/wavelets_flat-fr.png)
  </div>

Maintenant, en réduisant la force sur une fréquence spécifique, nous pouvons obtenir des résultats très différents. Voici ce que nous obtenons en abaissant la force sur une fréquence assez grossière :

  <div style="text-align: center">
![Bateau débruité avec moins de réduction de bruit sur la fréquence centrale](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/wavelets_coarse_noise-fr.png)
  </div>

Le résultat n'est pas agréable pour les yeux car les bruits de grains grossiers sont très perturbants. Ici, nous réduisons trop la force de débruitage.

Essayons le même test sur la fréquence la plus fine :

  <div style="text-align: center">
![Bateau débruité avec moins de réduction sur la fréquence la plus fine](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/wavelets_details-fr.png)
  </div>

On obtient ici une image beaucoup moins gênante que la précédente : le bruit du grain fin est moins dérangeant que celui à grain grossier. Cette image est même sans doute plus naturelle que celle avec une courbe plate.

En jouant avec les différentes fréquences, on peut obtenir de meilleurs compromis entre lissage et conservation des détails.

De plus, de nouveaux préréglages qui exploitent cette courbe sont maintenant disponibles pour le module _réduction du bruit (profil)_ :

* un pour le bruit de chrominance (fausses couleurs), où le bruit est augmenté pour les détails les plus fins, la couleur ne devant pas trop changer d'un pixel à l'autre ;

* un pour le bruit de luminance (fausse luminance), où le débruitage est réduit aux détails les plus fins et à certaines échelles grossières. Son objectif est de trouver un bon compromis entre bruit et lissage pour des images peu bruyantes (oubliez les valeurs ISO étendues, par exemple. Pour de telles images, nous devons utiliser des stratégies moins automatiques).

Le préréglage chroma doit être utilisé en première instance et le préréglage luma en deuxième instance.

Vous pouvez utiliser les courbes RGB pour des images plus complexes ou pour obtenir un meilleur compromis. En effet, les capteurs capturent généralement les valeurs R, G et B. En fonction de l'éclairage de la scène, les canaux peuvent présenter différentes caractéristiques de bruit :

* l'un des canaux peut être plus (ou même beaucoup plus) bruyant que l'autre

* un canal peut avoir un bruit plus grossier qu'un autre

Vous pouvez essayer d’obtenir un meilleur compromis de débruitage en débruitant les canaux séparément, à l’aide des courbes RGB et d’une instance du mélangeur de canaux permettant de visualiser les canaux :

  <div style="text-align: center">
![Débruitage du canal rouge](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/wavelets_red-fr.png)
  </div>

Une fois que les canaux RGB ont été débruités, vous pouvez utiliser une autre instance en mode de fusion couleurs pour éliminer les problèmes de couleur restants.

Notez que le débruitage des canaux RGB individuellement doit être effectué _avant_ d'utiliser une instance en mode de fusion couleurs, car cela mélangera les canaux et modifiera les caractéristiques du bruit.

Ces explications utilisaient le module _réduction du bruit (profil)_ comme exemple, mais vous pouvez suivre les mêmes étapes avec le module _réduction du bruit RAW_.
Notez également que le principe de débruiter des canaux RGB séparément en les visualisant à l'aide du mélangeur de canaux est également utile pour définir les paramètres du module _réduction du bruit (bilatéral)_.

## Un nouveau mode _logarithmique_ pour le module _correction du profil d'entrée_

De la même manière que la `transformation logarithmique` du module _filmique_, le module _correction du profil d’entrée_ est désormais équipé d’un mode logarithmique, avec les mêmes curseurs et sélecteurs. La différence est que _correction du profil d’entrée_ vient avant l’application du profil d’entrée, tandis que _filmique_ vient plus tard dans le pipeline graphique.

L'utilisation du `mode logarithmique` du module _correction du profil d'entrée_ donne généralement une image pâle, sans contraste. Par exemple, sur l'image [Mairi Troisieme](https://discuss.pixls.us/t/playraw-mairi-troisieme/967), nous obtenons cela :

  <div style="text-align: center">
![Image pâle après utilisation du module correction du profil d'entrée](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/unbreak-fade-fr.png)
  </div>

Obtenir une image pâle est en fait l'objectif : le `mode logarithmique` du module _correction du profil d'entrée_ est fait pour être utilisé en complément d'un autre module ultérieurement dans le pipeline graphique afin de donner plus de pep's à l'image (par exemple avec le module de _balance couleur_, particulièrement avec les nouvelles fonctionnalités de cette version).
L'avantage de ce flux est que la majeure partie du pipeline graphique, en particulier l'application du profil de couleur d'entrée, est réalisée sur une image qui s'étend correctement sur l'histogramme, sans valeurs extrêmes. En d’autres termes, nous distinguons une partie technique de l'édition et une partie artistique.

Revenons à notre image où la balance des couleurs permet par exemple ceci :

  <div style="text-align: center">
![Image vive après utilisation du module balance couleur](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/unbreak-colorbalanced-fr.png)
  </div>

Notez que dans ce flux de travail, il est obligatoire de travailler dans le même ordre que le pipeline graphique : essayez d'ajuster les paramètres du module _correction du profil d'entrée_ après le réglage des niveaux et du contraste avec le module _balance couleur_ est voué à l'échec.

En pratique, le module _filmique_ peut faire plus ou moins la même chose, mais à l'avantage de tout avoir dans un seul module permettant une édition plus rapide.

## Possibilité d'ajuster l'opacité de chaque correction du module _correction de taches_

Le module _correction de taches_ bénéficie de certaines des fonctionnalités intéressantes du module _retouche_. Par exemple, il est désormais possible de définir l'opacité des formes individuellement (`Contrôle`+`clic`).

## Amélioration de la gestion des fichiers RAW monochromes

Bien qu'il soit possible de transformer n'importe quelle image RAW en monochrome, certaines caméras n'ont pas de filtres de couleurs devant leurs capteurs et produisent des fichiers RAW monochromes. Les versions précédentes de darktable permettaient de désactiver le module _dématriçage_ pour le format RAW monochrome. Cette version améliore encore le traitement de ces images en désactivant la correction des aberrations chromatiques, le module _balance des blancs_ (ne serait-ce que pour éviter les messages d'erreurs parasites), et en ré-activant le traitement de base tel que l'exposition automatique désactivée dans les précédentes versions.

## Amélioration de la gestion des instances multiples de modules

### Possibilité de renommer les instances de module

Lorsqu’on utilise plusieurs instances du même module à des fins différentes, il est souvent difficile de se rappeler quelle instance sert à quoi. Maintenant, darktable permet de donner un nom à chaque instance pour simplifier cela.
Par exemple, si vous utilisez deux occurrences de _réduction du bruit (profil)_, une pour le bruit de chrominance et une pour le bruit de luminance, vous pouvez définir le nom du premier comme « chroma » et le nom du second comme « luma ».

Les étapes pour définir le nom de l'instance de chrominance sont décrites ci-dessous :

  <div style="text-align: center">
![Renommer une instance](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/rename-fr.png)
  </div>

1. tout d'abord, cliquez sur le bouton `actions instances multiples` ;
2. cliquez sur `renommer` ;
3. entrez le nom ;
4. appuyez sur `entrée` sur votre clavier.

Donner un nom à une instance de module n'est pas seulement un moyen pratique de se souvenir de qui fait quoi : darktable utilise aussi cette information pour le copier-coller d'historique, décrit juste après.

### Amélioration du copier/coller

L'une des forces de darktable est, grâce à sa nature non destructive, la possibilité d'appliquer l'historique d'une image sur une autre. Un historique peut être enregistré en tant que style ou copié d'une image à une autre (en utilisant `contrôle`-`c`/`contrôle`-`v` dans la _table lumineuse_ ou la _chambre noire_, ou en utilisant le module _développement_ dans la _table lumineuse_).

Une difficulté, cependant, consiste à décider de ce qui doit se passer lors du copier-coller d’un historique contenant un module sur une image cible où le module est déjà utilisé. Par défaut, darktable remplace le module existant par celui copié-collé. Toutefois, lorsque le même module est utilisé à des fins différentes dans les images source et cible, ce comportement n'est pas satisfaisant.
Dans darktable 2.6, le comportement est le suivant : lorsque les modules des images source et cible ont des noms différents, les deux instances sont conservées. S'ils portent le même nom, le copié-collé remplace l'ancien.

### Appliquer un style en un clic à une nouvelle instance

Travailler avec plusieurs instances du même module devient de plus en plus facile. Un cas d’utilisation courant consiste à créer une instance pour un réglage prédéfini, par exemple, le module _réduction du bruit (profil)_ est souvent utilisé avec une instance pour traiter le bruit de luminance, et une autre pour la chrominance.

Avec les versions précédentes, cela se faisait en plusieurs étapes :

1) créer une nouvelle instance,
2) appliquer le préréglage (4 clics).

Il est maintenant possible de le faire en une seule étape : ouvrez le menu `pré-réglages` et utilisez le bouton du milieu de la souris au lieu du bouton gauche pour sélectionner l’entrée :

  <div style="text-align: center">
![Créer une instance pour un pré-réglage](https://raw.githubusercontent.com/Nilvus/dtorg/593ec883671f7f39454711ceb0a69fad8cac5db7/content/blog/2018-12-25-darktable-2.6/second-instance-fr.png)
  </div>

Notez que la version qui suivra la 2.6 permettra d'ouvrir le menu `pré-réglage` par un clic du bouton du milieu de la souris.

## Recadrage préservant le ratio dans le module _correction de perspective_

Le module _correction de perspective_ permet désormais un recadrage semi-automatique préservant le format original de l'image :

  <div style="text-align: center">
![Recadrage automatique depuis le format original](https://raw.githubusercontent.com/Nilvus/dtorg/2f031849b7818b775cee0151502daa2ad16f6195/content/blog/2018-12-25-darktable-2.6/pc-original-format-fr.png)
  </div>

Glissez simplement la souris sur l'image pour sélectionner la portion à recadrer :

  <div style="text-align: center">
![Recadrer une image](https://raw.githubusercontent.com/Nilvus/dtorg/2f031849b7818b775cee0151502daa2ad16f6195/content/blog/2018-12-25-darktable-2.6/pc-crop-image.jpg)
  </div>

L'aire est ajustée automatiquement afin d'éviter d'inclure des parties noires de l'image cible. Ceci évite d'avoir à passer au module _recadrer et pivoter_.

# Améliorations d'ergonomie

## Aide contextuelle

Le logiciel darktable est une bête complexe à maîtriser, et lire le manuel pour la fonctionnalité que vous essayez d'utiliser est souvent une bonne idée, même si vous avez déjà lu le manuel complet. Cette version introduit une aide contextuelle pour aider les utilisateurs : un bouton `?` est disponible en haut à droite de l'interface, à côté du bouton `préférences` :

  <div style="text-align: center">
![Aide contextuelle](https://raw.githubusercontent.com/darktable-org/dtorg/e2c7cca8dc4fdfa9b3872f1a6c5322b1790cfffa/content/blog/2018-12-25-darktable-2.6/contextual-help.png)
  </div>

Après sélection de ce bouton, le curseur de la souris se transforme en un point d'interrogation dès lors qu'il survole tout élément de l'interface ayant une aide disponible :

  <div style="text-align: center">
![Aide contextuelle activée](https://raw.githubusercontent.com/Nilvus/dtorg/ed56dde40b561aa851bbe0c568d520377d5489c5/content/blog/2018-12-25-darktable-2.6/contextual-help-active-fr.png)
  </div>

En cliquant ensuite sur l'élément, votre navigateur web s'ouvrira sur la section correspondante de la documentation darktable.

## Organisation des modules en onglets

La répartition des modules en groupes ou en onglets (_modules de base_, _modules de tonalité_, _modules de couleur_, _modules d'améliorations_ et _groupe d'effets_) est maintenant personnalisable. La distribution originale dans darktable suit une catégorisation thématique, mais certains utilisateurs préfèrent le regroupement par étapes du flux de travail.
Par exemple, le module _dématriçage_ est actuellement classé dans le groupe _modules de couleur_ parce qu'il traite les couleurs, mais il intervient très tôt dans le pipeline graphique ce qui peut avoir une incidence sur presque tous les autres modules. Il est donc judicieux de le classer dans le groupe de base.

Une nouvelle catégorisation a été proposée, mais les discussions entre les développeurs n’ont pas permis de parvenir à un consensus, car la modification des groupes risque de perturber les anciens utilisateurs habitués à la présentation originale.

Dans darktable 2.6, le compromis trouvé a été de permettre une disposition personnalisée.

Vous pouvez modifier cette disposition manuellement en éditant le fichier `.config/darktable/darktablerc`, ou utiliser l'un des scripts fournis dans la distribution source de darktable : `tools/iop-layout.sh` afin d'adopter une nouvelle disposition, et `tools/iop-layout-legacy.sh` pour revenir à celle d'origine.

Éditez ces scripts si vous souhaitez créer votre disposition personnelle. Ces scripts sont faits pour des utilisateurs avancés qui savent comment en exécuter un. Il n'est pas garanti qu'ils fonctionnent sous Windows. Si un consensus se dégage sur la meilleure présentation possible, celle-ci pourra être adoptée dans les futures versions de darktable afin que tous les utilisateurs puissent en bénéficier.

Notez que ce changement n'affecte que l'interface. Changer la répartition des modules des différents groupes n'affecte pas l'ordre dans lequel les modules sont appliqués, ordre de traitement qui reste fixe (du bas vers le haut de l'interface affichée).

## Module _Courbe des tonalités_

L'interface utilisateur du module _courbe des tonalités_ a été améliorée de plusieurs façons. Premièrement, vous pouvez désormais utiliser une échelle logarithmique sur l'axe X ou l'axe Y, ou sur les deux :

  <div style="text-align: center">
![Échelle log-log sur la courbe de tonalités](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/tone-curve-loglog-fr.png)
  </div>

Ceci facilite la manipulation des points proches de zéro, c'est-à-dire affiner plus finement la partie de la courbe affectant les ombres.

Il est également possible de choisir l'algorithme utilisé pour l'interpolation, c'est-à-dire pour calculer la courbe elle-même en fonction des points de contrôle édités par l'utilisateur. Il y avait déjà plusieurs algorithmes disponibles, mais masqués à l'utilisateur. Par exemple, sélectionner le paramètre prédéfini `contraste - haut (linéaire)` sélectionnait pour vous une spline cubique. Pour les courbes très lisses, l’algorithme d’interpolation ne modifie pas beaucoup le résultat, mais pour les courbes utilisant des points proches les uns des autres, il peut provoquer des modifications importantes.

Par exemple, regardons le même ensemble de points de contrôle à différentes interpolations. Le mode `spline cubique` donne une courbe très lisse, mais peut donner un résultat non monotone, c'est-à-dire une inversion de contraste sur l'image résultante :

  <div style="text-align: center">
![spline cubique](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/tone-curve-cubic-fr.png)
  </div>

Le mode `spline centripète` réduit le risque d'obtenir une courbe non-monotone :

  <div style="text-align: center">
![spline centripète](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/tone-curve-centripetal-fr.png)
  </div>

Le mode `spline monotone`, utilisé par défaut, peut être moins lisse mais évite de fait la non-monotonie :

  <div style="text-align: center">
![spline monotone](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/tone-curve-monotonic-fr.png)
  </div>

## Interface utilisateur plus personnalisable avec les feuilles de style CSS

Plus d'éléments sont personnalisables via CSS. En particulier, certains qui étaient codés en dur avec un avant-plan clair et un arrière-plan sombre, ce qui rendait impossible d'avoir un thème à l'arrière-plan clair.

Il est maintenant possible d'avoir un thème clair avec, par exemple, la CSS suivante (dans un fichier nommé `darktable.css` dans le répertoire de configuration de darktable, c'est-à-dire `~/.config/darktable/` sur les systèmes unix ; pour plus d'informations et autres systèmes d'exploitation, voir sur [darktable.fr](https://darktable.fr/les-fichiers-de-configuration/)) :

```css
/* Remplacer le chemin ci-dessous par le chemin vers le fichier darktable.css de darktable 2.6 */
@import '/usr/share/darktable/darktable.css';

@define-color bg_color #eee;
@define-color plugin_bg_color #aaa;
@define-color fg_color #333;
@define-color base_color #444;
@define-color text_color #333;
@define-color selected_bg_color #eee;
@define-color selected_fg_color #666;
@define-color tooltip_bg_color #ddd;
@define-color tooltip_fg_color #eee;
@define-color really_dark_bg_color #eee;

@define-color darkroom_bg_color #fff;
@define-color darkroom_preview_bg_color shade(@darkroom_bg_color, .8);
@define-color lighttable_bg_color @darkroom_bg_color;
@define-color lighttable_preview_bg_color shade(@lighttable_bg_color, .8);

tooltip
{
    border-radius: 0pt;
}
#iop-plugin-ui
{
    border: 1pt solid #aaa;
}
```

L'interface ressemblera alors à ceci :

  <div style="text-align: center">
![White background CSS](https://raw.githubusercontent.com/moy/dtorg/30b9baa/content/blog/2018-12-25-darktable-2.6/white-background-css-fr.jpg)
  </div>

Attention, avec une interface claire comme celle-ci, les images apparaissent artificiellement plus sombres. L'utilisateur sera donc tenté de surexposer ses images. Travailler sur fond clair reste intéressant pour les photographes qui travaillent sur des images destinées à être affichées sur fond clair ou blanc. Pour éviter d'être influencé vers la sur- ou sous-exposition, un thème [gris, comme celui dont nous avions parlé l'an passé](https://linuxfr.org/news/darktable-2-4-0#possibilit%C3%A9-de-choisir-la-couleur-de-fond-de-linterface-via-css) est bien plus recommandable.

À noter que les miniatures de la table lumineuse utilisent toujours des couleurs codées en dur, mais ceci devrait changer dans la prochaine version.

## Autres améliorations

* Les niveaux de zoom 50%, 400%, 800% et 1600% sont disponibles dans la chambre noire. Alors que la plupart des opérations fournies par darktable ont pour objectif d'améliorer les couleurs et la tonalité de l'image globale, il est parfois intéressant d’obtenir une vue précise au niveau des pixels sur une petite partie de l’image. Le facteur de zoom le plus élevé précédemment disponible (200%) n'était pas toujours suffisant, spécialement sur des écrans à haute résolution. Notez que ces niveaux de zoom sont accessibles dans le menu de la zone d'aperçu, mais pas avec la molette de la souris.

  <div style="text-align: center">
![Niveau de zoom 1600%](https://raw.githubusercontent.com/Nilvus/dtorg/18067580e82522fd1387ead7a90661259b25f1b0/content/blog/2018-12-25-darktable-2.6/zoom-1600-fr.png)
  </div>

* Tous les masques sont prévisualisés et peuvent être ajustés avant d'être dessinés. Ceci s'applique également aux formes du module _liquéfier_.

* Le fonctionnement de la pipette de couleur a été retravaillé. Par exemple, la pipette du module _exposition_ n'était pas désactivée lorsque le module l'était. Corriger cela est devenu plus important avec de plus en plus de modules utilisant la pipette (_filmique_, _correction du profil d'entrée_, _balance couleur_).

# Import depuis d'autres logiciels

* L'importation depuis Adobe Lightroom a été amélioré (les métadonnées « créateur », « droits », « titre » et « description » sont copiées de Lightroom vers darktable).
* Un nouveau script est fourni pour importer les collections depuis Capture One Pro (`tools/migrate_capture_one_pro.sql` dans le code source de darktable).

# À propos de cet article

Cet article est sous les termes de la licence [Attribution 2.0 Générique (CC BY 2.0) (CC BY 2.0)](https://creativecommons.org/licenses/by/2.0/deed.fr), ou, selon, de la [Licence Creative Commons BY-NC-SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/deed.fr).

**Contributeurs :** [jpg54](https://www.flickr.com/photos/113336874@N07/), [Matthieu Moy](https://matthieu-moy.fr/), [Nilvus](https://github.com/Nilvus), [rawfiner](https://github.com/rawfiner).
